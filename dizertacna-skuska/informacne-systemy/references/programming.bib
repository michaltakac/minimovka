@article{Bengtsson2013,
abstract = {A fundamental functionality of a Programmable Logic Controller (PLC) is to control and execute a set of operations. But a large part of the program code is more involved in supporting the user with concerns like alarm, HMI, communication, safety and manual control. Code related to these supporting concerns is often tangled with operation execution code, the core concerns, which makes it hard to reuse. This paper describes a method to reuse code and functionality when developing PLC programs and code libraries. The method proposes that core concerns are planned with a software tool called Sequence Planner, and the supporting concerns are integrated into the core concerns with a tool based on aspect-oriented programming. {\textcopyright} 2012 Elsevier Ltd.},
author = {Bengtsson, Kristofer and Lennartson, Bengt and Ljungkrantz, Oscar and Yuan, Chengyin},
doi = {10.1016/j.conengprac.2012.09.002},
file = {:Users/michaltakac/Library/Application Support/Mendeley Desktop/Downloaded/Bengtsson et al. - 2013 - Developing control logic using aspect-oriented programming and sequence planning.pdf:pdf},
issn = {09670661},
journal = {Control Engineering Practice},
keywords = {Aspect-oriented programming,IEC 61131-3,Reusability},
number = {1},
pages = {12--22},
publisher = {Elsevier},
title = {{Developing control logic using aspect-oriented programming and sequence planning}},
url = {http://dx.doi.org/10.1016/j.conengprac.2012.09.002},
volume = {21},
year = {2013}
}
@article{Murphy2006,
author = {Murphy, Gail and Schwanninger, Christa},
doi = {10.1007/978-1-4302-0863-1_4},
file = {:Users/michaltakac/Library/Application Support/Mendeley Desktop/Downloaded/Murphy, Schwanninger - 2006 - Aspect-Oriented Programming.pdf:pdf},
journal = {Google Guice: Agile Lightweight Dependency Injection Framework},
pages = {59--69},
title = {{Aspect-Oriented Programming}},
url = {http://link.springer.com/10.1007/978-1-4302-0863-1{\_}4},
year = {2006}
}
@article{Hoffman2009,
abstract = {Aspect-oriented programming (AOP) seeks to improve software modularity via the separation of cross-cutting concerns. AOP proponents often advocate a development strategy where programmers write the main application (base code), ignoring cross-cutting concerns, and then aspect programmers, domain experts in their specific concerns, weave in the logic for these more specialized cross-cutting concerns. This purely oblivious strategy, however, has empirically been shown to tightly couple aspects to base code in many cases, hindering aspect modularity and reuse. In essence, the more intricate the weaving between the cross-cutting concern and the base code (lexically and/or semantically), the harder it becomes to: (a) robustly specify how to weave the aspects in at the required points, (b) capture interactions between aspects and base code, and (c) preserve the correct weaving as the base code evolves. We propose an alternate methodology, termed cooperative aspect-oriented programming (Co-AOP), where complete lexical separation of concerns is not taken as an absolute requirement. Instead, cross-cutting concerns are explicitly modeled as abstract interfaces through explicit join points (EJPs). Programmers specify where these interfaces interact with base code either through explicit lexical references or via traditional oblivious aspects. This explicit awareness allows base code and aspects to cooperate in ways that were previously not possible: arbitrary blocks of code can be advised, advice can be explicitly parameterized, base code can guide aspects in where to apply advice, and aspects can statically enforce new constraints upon the base code that they advise. These new techniques allow aspect modularity and program safety to increase, and bring us towards a cooperative AOP paradigm. We illustrate our methodology via an example on transactions, and also give an initial evaluation of cooperative AOP through an empirical study on program extensibility comparing both the traditional and cooperative AOP methodologies. Initial results show that cooperative AOP techniques result in code that is less complex with lower overall coupling, facilitating extensibility. {\textcopyright} 2009 Elsevier B.V. All rights reserved.},
author = {Hoffman, Kevin and Eugster, Patrick},
doi = {10.1016/j.scico.2009.01.003},
file = {:Users/michaltakac/Documents/Research/programming/Cooperative aspect-oriented programming.pdf:pdf},
isbn = {0167-6423},
issn = {01676423},
journal = {Science of Computer Programming},
keywords = {Aspect-oriented programming,Extensibility,Join point,Modularity},
number = {5-6},
pages = {333--354},
publisher = {Elsevier B.V.},
title = {{Cooperative aspect-oriented programming}},
url = {http://dx.doi.org/10.1016/j.scico.2009.01.003},
volume = {74},
year = {2009}
}
@article{Tanguy2013,
abstract = {This series of five volumes proposes an integrated description of physical processes modeling used by scientific disciplines from meteorology to coastal morphodynamics. Volume 1 describes the physical processes and identifies the main measurement devices used to measure the main parameters that are indispensable to implement all these simulation tools. Volume 2 presents the different theories in an integrated approach: mathematical models as well as conceptual models, used by all disciplines to represent these processes. Volume 3 identifies the main numerical methods used in all these scientific fields to translate mathematical models into numerical tools. Volume 4 is composed of a series of case studies, dedicated to practical applications of these tools in engineering problems. To complete this presentation, volume 5 identifies and describes the modeling software in each discipline.},
author = {Tanguy, Jean Michel},
doi = {10.1002/9781118557891},
file = {:Users/michaltakac/Library/Application Support/Mendeley Desktop/Downloaded/Tanguy - 2013 - Modeling Software.pdf:pdf},
isbn = {9781848211575},
issn = {16601769},
journal = {Modeling Software},
pages = {1--44},
title = {{Modeling Software}},
volume = {5},
year = {2013}
}
@article{Ohshima2005,
abstract = {Decentralized and complex systems can be powerful tools for modeling concepts in mathematics, science and engineering. Star Logo and NetLogo were the first systems to allow middle and high school children to build dynamic models from many thousands of programmable particles. This has inspired Kedama: an authoring system that simplifies the scripting and construction of massively parallel models to allow more students to join in this new rich environment. This has given rise to new user interface and programming language designs. Kedama has the following notable features: 1) scripts in Kedama can be written in a graphical tile scripting interface. Its users are alleviated from syntax errors, and all program elements are visually presented to the user. 2) Kedama is an extension of Squeak eToys: children who have learned to "script in the large" can use same techniques to "script in the small" with many thousands of objects. 3) The semantics and syntax are simplified but retain full power of expression. 4) The ill in Kedama is dynamic: scripts and other properties in Kedama can be dynamically modified while scripts are kept running. 5) Kedama is more portable, being able to run on more than two dozen types of platforms, including the most used around the world. 6) Kedama is fast. Various simulations typically run about 3 times faster than previous systems. This improvement made it possible to write different classes of examples.},
author = {Ohshima, Yoshiki},
doi = {10.1109/VLHCC.2005.49},
file = {:Users/michaltakac/Library/Application Support/Mendeley Desktop/Downloaded/Ohshima - 2005 - Kedama A GUI-based interactive massively parallel particle programming system.pdf:pdf},
isbn = {0769524435},
journal = {Proceedings - 2005 IEEE Symposium on Visual Languages and Human-Centric Computing},
pages = {91--98},
title = {{Kedama: A GUI-based interactive massively parallel particle programming system}},
volume = {2005},
year = {2005}
}
@article{Tanter2014,
abstract = {In aspect-oriented programming (AOP) languages, advice evaluation is usually considered as part of the base program evaluation. This is also the case for certain pointcuts, such as if pointcuts in AspectJ, or simply all pointcuts in higher-order aspect languages like AspectScheme. While viewing aspects as part of base level computation clearly distinguishes AOP from reflection, it also comes at a price: because aspects observe base level computation, evaluating pointcuts and advice at the base level can trigger infinite regression. To avoid these pitfalls, aspect languages propose ad-hoc mechanisms, which increase the complexity for programmers while being insufficient in many cases. After shedding light on the many facets of the issue, this paper proposes to clarify the situation by introducing levels of execution in the programming language, thereby allowing aspects to observe and run at specific, possibly different, levels. We adopt a defensive default that avoids infinite regression, and gives advanced programmers the means to override this default using level-shifting operators. We then study execution levels both in practice and in theory. First, we study the relevance of the issues addressed by execution levels in existing aspect-oriented programs. We then formalize the semantics of execution levels and prove that the default semantics is indeed free of a certain form of infinite regression, which we call aspect loops. Finally, we report on existing implementations of execution levels for aspect-oriented extensions of Scheme, JavaScript and Java, discussing their implementation techniques and current applications. {\textcopyright} 2013 Elsevier B.V.},
author = {Tanter, {\'{E}}ric and Figueroa, Ismael and Tabareau, Nicolas},
doi = {10.1016/j.scico.2013.09.002},
file = {:Users/michaltakac/Library/Application Support/Mendeley Desktop/Downloaded/Tanter, Figueroa, Tabareau - 2014 - Execution levels for aspect-oriented programming Design, semantics, implementations and applications.pdf:pdf},
issn = {01676423},
journal = {Science of Computer Programming},
keywords = {Aspect-oriented programming,Execution levels,Infinite regression,Meta-programming},
number = {PART B},
pages = {311--342},
publisher = {Elsevier B.V.},
title = {{Execution levels for aspect-oriented programming: Design, semantics, implementations and applications}},
url = {http://dx.doi.org/10.1016/j.scico.2013.09.002},
volume = {80},
year = {2014}
}
