
@article{cavarleFeatureorientedModeldrivenEngineering2018,
	title = {A feature-oriented model-driven engineering approach for the early validation of feature-based applications},
	volume = {161},
	issn = {01676423},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S0167642318300017},
	doi = {10.1016/j.scico.2018.01.001},
	abstract = {The software industry has to offer increasingly individualized software for a large number of platforms. In a constantly evolving technical context, the appropriateness and the proﬁtableness of a software has to be ensured earlier, before most of the costs have been incurred and before most of the risks have been taken. Feature-Oriented ModelDriven Development (FOMDD) is a promising paradigm to tackle the issue of developing software variants when multiple platforms are targeted. However, because of its modeldriven fundament, FOMDD suffers from limited capabilities regarding model execution and early validation. In this paper, we present CrossFabrik, an approach for the design and the early functional validation of feature-based applications. This approach allows the live debugging and editing of the underlying models during a simulation without being forced to stop and restart a validation process. Such an approach relies on the reﬂective capability of the development environment. An implementation of our approach within Pharo is also presented.},
	language = {en},
	urldate = {2018-09-24},
	journal = {Science of Computer Programming},
	author = {Cavarlé, Glenn and Plantec, Alain and Costiou, Steven and Ribaud, Vincent},
	month = sep,
	year = {2018},
	pages = {18--33},
	file = {Cavarlé et al. - 2018 - A feature-oriented model-driven engineering approa.pdf:/Users/michaltakac/Zotero/storage/C7PKGC8J/Cavarlé et al. - 2018 - A feature-oriented model-driven engineering approa.pdf:application/pdf}
}

@inproceedings{felgentreffHowBuildHighPerformance2016,
	address = {Prague, Czech Republic},
	title = {How to {Build} a {High}-{Performance} {VM} for {Squeak}/{Smalltalk} in {Your} {Spare} {Time}: {An} {Experience} {Report} of {Using} the {RPython} {Toolchain}},
	isbn = {978-1-4503-4524-8},
	shorttitle = {How to {Build} a {High}-{Performance} {VM} for {Squeak}/{Smalltalk} in {Your} {Spare} {Time}},
	url = {http://dl.acm.org/citation.cfm?doid=2991041.2991062},
	doi = {10.1145/2991041.2991062},
	abstract = {In this paper we present our experience in letting students develop RSqueak/VM, a fast virtual machine for executing Squeak/Smalltalk, over the course of multiple introductory VM courses and projects. Our experience indicates that the way RSqueak/VM is constructed makes it easy for developers with little or no prior exposure to VM development to construct a Squeak runtime that is very nearly competitive to the professional grade Cog VM, which is used by Squeak and other ﬂavors of Smalltalk. In this experience report we discuss the beneﬁts and drawbacks of RSqueak/VM as a research vehicle for developing and evaluating Smalltalk language extensions without having to learn the deep secrets of VM development.},
	language = {en},
	urldate = {2018-09-24},
	booktitle = {Proceedings of the 11th edition of the {International} {Workshop} on {Smalltalk} {Technologies} - {IWST}'16},
	publisher = {ACM Press},
	author = {Felgentreff, Tim and Pape, Tobias and Rein, Patrick and Hirschfeld, Robert},
	year = {2016},
	pages = {1--10},
	file = {Felgentreff et al. - 2016 - How to Build a High-Performance VM for SqueakSmal.pdf:/Users/michaltakac/Zotero/storage/EK8A3TUZ/Felgentreff et al. - 2016 - How to Build a High-Performance VM for SqueakSmal.pdf:application/pdf}
}

@article{callauHowWhyDevelopers2013,
	title = {How (and why) developers use the dynamic features of programming languages: the case of smalltalk},
	volume = {18},
	issn = {1382-3256, 1573-7616},
	shorttitle = {How (and why) developers use the dynamic features of programming languages},
	url = {http://link.springer.com/10.1007/s10664-012-9203-2},
	doi = {10.1007/s10664-012-9203-2},
	abstract = {The dynamic and reflective features of programming languages are powerful constructs that programmers often mention as extremely useful. However, the ability to modify a program at runtime can be both a boon—in terms of flexibility—, and a curse—in terms of tool support. For instance, usage of these features hampers the design of type systems, the accuracy of static analysis techniques, or the introduction of optimizations by compilers. In this paper, we perform an empirical study of a large Smalltalk codebase—often regarded as the poster-child in terms of availability of these features—, in order to assess how much these features are actually used in practice, whether some are used more than others, and in which kinds of projects. In addition, we performed a qualitative analysis of a representative sample of usages of dynamic features in order to uncover (1) the principal reasons that drive people to use dynamic features, and (2) whether and how these dynamic feature usages can be removed or converted to safer usages. These results are useful to make informed decisions about which features to consider when designing language extensions or tool support.},
	language = {en},
	number = {6},
	urldate = {2018-09-24},
	journal = {Empirical Software Engineering},
	author = {Callaú, Oscar and Robbes, Romain and Tanter, Éric and Röthlisberger, David},
	month = dec,
	year = {2013},
	pages = {1156--1194},
	file = {Callaú et al. - 2013 - How (and why) developers use the dynamic features .pdf:/Users/michaltakac/Zotero/storage/4PFJCKE4/Callaú et al. - 2013 - How (and why) developers use the dynamic features .pdf:application/pdf}
}

@article{leskeImprovingLiveDebugging2018,
	title = {Improving live debugging of concurrent threads through thread histories},
	volume = {161},
	issn = {01676423},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S0167642317302174},
	doi = {10.1016/j.scico.2017.10.005},
	abstract = {Concurrency issues are inherently harder to identify and ﬁx than issues in sequential programs, due to aspects like indeterminate order of access to shared resources and thread synchronisation. Live debuggers are often used by developers to gain insights into the behaviour of concurrent programs by exploring the call stacks of threads. Nevertheless, contemporary live debuggers for concurrent programs are usually sequential debuggers augmented with the ability to display different threads in isolation. To these debuggers every thread call stack begins with a designated start routine and the calls that led to the creation of the thread are not visible, as they are part of a different thread. This requires developers to manually link stack traces belonging to related but distinct threads, adding another burden to the already diﬃcult act of debugging concurrent programs. To improve debugging of concurrent programs we address the problem of incomplete call stacks in debuggers through a thread and debugger model that enables live debugging of child threads within the context of their parent threads. The proposed debugger operates on a virtual thread that merges together multiple relevant threads. To better understand the features of debuggers for concurrent programs we present an in-depth discussion of the concurrency related features in current live debuggers. We test the applicability of the proposed model by instantiating it for simple threads, local and remote promises, and a remote object-oriented database. Starting from these use cases we further discuss implementation details ensuring a practical approach.},
	language = {en},
	urldate = {2018-09-24},
	journal = {Science of Computer Programming},
	author = {Leske, Max and Chiş, Andrei and Nierstrasz, Oscar},
	month = sep,
	year = {2018},
	pages = {122--148},
	file = {Leske et al. - 2018 - Improving live debugging of concurrent threads thr.pdf:/Users/michaltakac/Zotero/storage/ZHHENGS5/Leske et al. - 2018 - Improving live debugging of concurrent threads thr.pdf:application/pdf}
}

@article{costiouLubPatternFine2018,
	title = {Lub: {A} pattern for fine grained behavior adaptation at runtime},
	volume = {161},
	issn = {01676423},
	shorttitle = {Lub},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S0167642317301946},
	doi = {10.1016/j.scico.2017.09.006},
	abstract = {Autonomous systems have to evolve in complex environments and their software must adapt to various situations. Although it is common to anticipate adaptations at design time, it becomes a more complex issue when facing unpredictable contexts at runtime, especially if applications cannot be stopped. We introduce Lub, a pattern designed to extend object oriented languages with ﬁne grained unanticipated adaptations. Lub is based on dynamic instrumentation of the lookup, and allows objects to acquire behaviors from another class than their own. A Pharo Smalltalk implementation of Lub is evaluated through a performance analysis and a running example of a ﬂeet of drones facing unexpected GPS problems. Lub is then discussed from the unanticipated software adaptation perspective.},
	language = {en},
	urldate = {2018-09-24},
	journal = {Science of Computer Programming},
	author = {Costiou, Steven and Kerboeuf, Mickaël and Cavarlé, Glenn and Plantec, Alain},
	month = sep,
	year = {2018},
	pages = {149--171},
	file = {Costiou et al. - 2018 - Lub A pattern for fine grained behavior adaptatio.pdf:/Users/michaltakac/Zotero/storage/789IDRQ8/Costiou et al. - 2018 - Lub A pattern for fine grained behavior adaptatio.pdf:application/pdf}
}

@article{fabryPHANtomModernAspect2014,
	title = {{PHANtom}: a modern aspect language for {Pharo} {Smalltalk}: {PHANTOM}: {A} {MODERN} {ASPECT} {LANGUAGE} {FOR} {PHARO} {SMALLTALK}},
	volume = {44},
	issn = {00380644},
	shorttitle = {{PHANtom}},
	url = {http://doi.wiley.com/10.1002/spe.2117},
	doi = {10.1002/spe.2117},
	abstract = {In the context of our research on Aspect-Oriented Programming, we have a need for a modern and powerful aspect language for Smalltalk. Current aspect languages for Smalltalk however fall short on various points. To address this deﬁcit, we elected to design and build PHANtom: a modern aspect language for Pharo Smalltalk. PHANtom is designed to be an aspect language in the spirit of Smalltalk: dynamic, simple, and powerful. PHANtom is a modern aspect language because it incorporates the best features of languages that precede it, includes recent research results in aspect interactions and reentrancy control, and is designed from the onset to be optimized and compiled where possible. In this paper, we present the latest version of the language and give examples and patterns of use. Copyright © 2012 John Wiley \& Sons, Ltd.},
	language = {en},
	number = {4},
	urldate = {2018-09-24},
	journal = {Software: Practice and Experience},
	author = {Fabry, Johan and Galdames, Daniel},
	month = apr,
	year = {2014},
	pages = {393--412},
	file = {Fabry and Galdames - 2014 - PHANtom a modern aspect language for Pharo Smallt.pdf:/Users/michaltakac/Zotero/storage/TU8YIXLW/Fabry and Galdames - 2014 - PHANtom a modern aspect language for Pharo Smallt.pdf:application/pdf}
}

@article{chisPracticalDomainspecificDebuggers2015,
	title = {Practical domain-specific debuggers using the {Moldable} {Debugger} framework},
	volume = {44},
	issn = {14778424},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S1477842415000561},
	doi = {10.1016/j.cl.2015.08.005},
	abstract = {Understanding the run-time behavior of software systems can be a challenging activity. Debuggers are an essential category of tools used for this purpose as they give developers direct access to the running systems. Nevertheless, traditional debuggers rely on generic mechanisms to introspect and interact with the running systems, while developers reason about and formulate domain-specific questions using concepts and abstractions from their application domains. This mismatch creates an abstraction gap between the debugging needs and the debugging support leading to an inefficient and error-prone debugging effort, as developers need to recover concrete domain concepts using generic mechanisms. To reduce this gap, and increase the efficiency of the debugging process, we propose a framework for developing domain-specific debuggers, called the Moldable Debugger, that enables debugging at the level of the application domain. The Moldable Debugger is adapted to a domain by creating and combining domain-specific debugging operations with domain-specific debugging views, and adapts itself to a domain by selecting, at run time, appropriate debugging operations and views. To ensure the proposed model has practical applicability (i.e., can be used in practice to build real debuggers), we discuss, from both a performance and usability point of view, three implementation strategies. We further motivate the need for domain-specific debugging, identify a set of key requirements and show how our approach improves debugging by adapting the debugger to several domains.},
	language = {en},
	urldate = {2018-09-24},
	journal = {Computer Languages, Systems \& Structures},
	author = {Chiş, Andrei and Denker, Marcus and Gîrba, Tudor and Nierstrasz, Oscar},
	month = dec,
	year = {2015},
	pages = {89--113},
	file = {Chiş et al. - 2015 - Practical domain-specific debuggers using the Mold.pdf:/Users/michaltakac/Zotero/storage/P7HH5Q2M/Chiş et al. - 2015 - Practical domain-specific debuggers using the Mold.pdf:application/pdf}
}

@article{lagadecPrefaceSpecialIssue2014,
	title = {Preface to the special issue on advances in {Smalltalk} based systems},
	volume = {96},
	issn = {01676423},
	url = {http://linkinghub.elsevier.com/retrieve/pii/S0167642314003141},
	doi = {10.1016/j.scico.2014.07.004},
	language = {en},
	urldate = {2018-09-24},
	journal = {Science of Computer Programming},
	author = {Lagadec, Loïc and Plantec, Alain},
	month = dec,
	year = {2014},
	pages = {1--3},
	file = {Lagadec and Plantec - 2014 - Preface to the special issue on advances in Smallt.pdf:/Users/michaltakac/Zotero/storage/5TN37PZE/Lagadec and Plantec - 2014 - Preface to the special issue on advances in Smallt.pdf:application/pdf}
}

@article{chisnallSmalltalkWorld2014,
	title = {Smalltalk in a {C} world},
	volume = {96},
	issn = {01676423},
	url = {http://linkinghub.elsevier.com/retrieve/pii/S0167642313002852},
	doi = {10.1016/j.scico.2013.10.013},
	abstract = {A modern developer is presented with a continuum of choices of programming languages, ranging from assembly languages and C up to high-level domain-speciﬁc languages. It is very rare for a single language to be the best possible choice for everything, and the sweet spot with an optimal trade between ease of development and performance changes depending on the target platform.},
	language = {en},
	urldate = {2018-09-24},
	journal = {Science of Computer Programming},
	author = {Chisnall, David},
	month = dec,
	year = {2014},
	pages = {4--16},
	file = {Chisnall - 2014 - Smalltalk in a C world.pdf:/Users/michaltakac/Zotero/storage/LADPYRVH/Chisnall - 2014 - Smalltalk in a C world.pdf:application/pdf}
}

@article{uquillasgomezRingUnifyingMetamodel2012,
	title = {Ring: {A} unifying meta-model and infrastructure for {Smalltalk} source code analysis tools},
	volume = {38},
	issn = {14778424},
	shorttitle = {Ring},
	url = {http://linkinghub.elsevier.com/retrieve/pii/S1477842411000443},
	doi = {10.1016/j.cl.2011.11.001},
	abstract = {Source code management systems record different versions of code. Tool support can then compute deltas between versions. To ease version history analysis we need adequate models to represent source code entities. Now naturally the questions of their deﬁnition, the abstractions they use, and the APIs of such models are raised, especially in the context of a reﬂective system which already offers a model of its own structure.},
	language = {en},
	number = {1},
	urldate = {2018-09-24},
	journal = {Computer Languages, Systems \& Structures},
	author = {Uquillas Gómez, Verónica and Ducasse, Stéphane and D'Hondt, Theo},
	month = apr,
	year = {2012},
	pages = {44--60},
	file = {Uquillas Gómez et al. - 2012 - Ring A unifying meta-model and infrastructure for.pdf:/Users/michaltakac/Zotero/storage/IFQ5H7G6/Uquillas Gómez et al. - 2012 - Ring A unifying meta-model and infrastructure for.pdf:application/pdf}
}

@article{aliSystematicReviewComparative2010a,
	title = {A systematic review of comparative evidence of aspect-oriented programming},
	volume = {52},
	issn = {09505849},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S0950584910000819},
	doi = {10.1016/j.infsof.2010.05.003},
	abstract = {Objective: This research aimed to systematically identify, analyze, and report the evidence published in the literature to support the claims made in favor or against AOP compared with non-AOP approaches.
Method: We performed a systematic literature review of empirical studies of AOP based development, published in major software engineering journals and conference proceedings.
Results: Our search strategy identiﬁed 3307 papers, of which 22 were identiﬁed as reporting empirical studies comparing AOP with non-AOP approaches. Based on the analysis of the data extracted from those 22 papers, our ﬁndings show that for performance, code size, modularity, and evolution related characteristics, a majority of the studies reported positive effects, a few studies reported insigniﬁcant effects, and no study reported negative effects; however, for cognition and language mechanism, negative effects were reported.
Conclusion: AOP is likely to have positive effect on performance, code size, modularity, and evolution. However its effect on cognition and language mechanism is less likely to be positive. Care should be taken using AOP outside the context in which it has been validated.},
	language = {en},
	number = {9},
	urldate = {2021-05-04},
	journal = {Information and Software Technology},
	author = {Ali, Muhammad Sarmad and Ali Babar, Muhammad and Chen, Lianping and Stol, Klaas-Jan},
	month = sep,
	year = {2010},
	pages = {871--887},
	file = {Ali et al. - 2010 - A systematic review of comparative evidence of asp.pdf:/Users/michaltakac/Zotero/storage/7QBR7UYA/Ali et al. - 2010 - A systematic review of comparative evidence of asp.pdf:application/pdf}
}

@article{murphyFocusguestEditorsIntroduction2006a,
	title = {focusguest editors’ introduction},
	abstract = {Shape class with concrete subclasses, such as Rectangle and Circle. A Display class makes shapes visible to the user. Developers can share the work needed to build the system by distributing work on the Shape hierarchy and on the Display class. The Shape hierarchy increases the system’s value: you can extend it to represent UML class diagram notation to support software design editing and display, solving a different problem using the same framework.},
	language = {en},
	journal = {IEEE SOFTWARE},
	author = {Murphy, Gail and Schwanninger, Christa},
	year = {2006},
	pages = {5},
	file = {Murphy and Schwanninger - 2006 - focusguest editors’ introduction.pdf:/Users/michaltakac/Zotero/storage/YKQPSQTL/Murphy and Schwanninger - 2006 - focusguest editors’ introduction.pdf:application/pdf}
}

@article{ramanConvertingDilatedIntegers2008a,
	title = {Converting to and from {Dilated} {Integers}},
	volume = {57},
	issn = {0018-9340},
	url = {http://ieeexplore.ieee.org/document/4358258/},
	doi = {10.1109/TC.2007.70814},
	abstract = {Dilated integers form an ordered group of the cartesian indices into a d-dimensional array represented in Morton order. Efﬁcient implementations of its operations can be found elsewhere; this paper offers efﬁcient casting (type)conversions to and from ordinary integer representation. As Morton-order representation for two- and three-dimensional arrays attracts more users because of its excellent block locality, the efﬁciency of these conversions becomes important. They are essential for programmers who would use cartesian indexing there.},
	language = {en},
	number = {4},
	urldate = {2021-05-04},
	journal = {IEEE Transactions on Computers},
	author = {Raman, R. and Wise, D.S.},
	month = apr,
	year = {2008},
	pages = {567--573},
	file = {Raman and Wise - 2008 - Converting to and from Dilated Integers.pdf:/Users/michaltakac/Zotero/storage/JZFD5WDH/Raman and Wise - 2008 - Converting to and from Dilated Integers.pdf:application/pdf}
}

@article{hoffmanCooperativeAspectorientedProgramming2009a,
	title = {Cooperative aspect-oriented programming},
	volume = {74},
	issn = {01676423},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S016764230900015X},
	doi = {10.1016/j.scico.2009.01.003},
	abstract = {Aspect-oriented programming (AOP) seeks to improve software modularity via the separation of cross-cutting concerns. AOP proponents often advocate a development strategy where programmers write the main application (base code), ignoring crosscutting concerns, and then aspect programmers, domain experts in their specific concerns, weave in the logic for these more specialized cross-cutting concerns. This purely oblivious strategy, however, has empirically been shown to tightly couple aspects to base code in many cases, hindering aspect modularity and reuse. In essence, the more intricate the weaving between the cross-cutting concern and the base code (lexically and/or semantically), the harder it becomes to: (a) robustly specify how to weave the aspects in at the required points, (b) capture interactions between aspects and base code, and (c) preserve the correct weaving as the base code evolves.},
	language = {en},
	number = {5-6},
	urldate = {2021-05-04},
	journal = {Science of Computer Programming},
	author = {Hoffman, Kevin and Eugster, Patrick},
	month = mar,
	year = {2009},
	pages = {333--354},
	file = {Hoffman and Eugster - 2009 - Cooperative aspect-oriented programming.pdf:/Users/michaltakac/Zotero/storage/H3EPGC5J/Hoffman and Eugster - 2009 - Cooperative aspect-oriented programming.pdf:application/pdf}
}

@article{bengtssonDevelopingControlLogic2013a,
	title = {Developing control logic using aspect-oriented programming and sequence planning},
	volume = {21},
	issn = {09670661},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S0967066112001852},
	doi = {10.1016/j.conengprac.2012.09.002},
	abstract = {A fundamental functionality of a Programmable Logic Controller (PLC) is to control and execute a set of operations. But a large part of the program code is more involved in supporting the user with concerns like alarm, HMI, communication, safety and manual control. Code related to these supporting concerns is often tangled with operation execution code, the core concerns, which makes it hard to reuse.},
	language = {en},
	number = {1},
	urldate = {2021-05-04},
	journal = {Control Engineering Practice},
	author = {Bengtsson, Kristofer and Lennartson, Bengt and Ljungkrantz, Oscar and Yuan, Chengyin},
	month = jan,
	year = {2013},
	pages = {12--22},
	file = {Bengtsson et al. - 2013 - Developing control logic using aspect-oriented pro.pdf:/Users/michaltakac/Zotero/storage/RBWI82ZT/Bengtsson et al. - 2013 - Developing control logic using aspect-oriented pro.pdf:application/pdf}
}

@article{tanterExecutionLevelsAspectoriented2014a,
	title = {Execution levels for aspect-oriented programming: {Design}, semantics, implementations and applications},
	volume = {80},
	issn = {01676423},
	shorttitle = {Execution levels for aspect-oriented programming},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S0167642313002244},
	doi = {10.1016/j.scico.2013.09.002},
	abstract = {In aspect-oriented programming (AOP) languages, advice evaluation is usually considered as part of the base program evaluation. This is also the case for certain pointcuts, such as if pointcuts in AspectJ, or simply all pointcuts in higher-order aspect languages like AspectScheme. While viewing aspects as part of base level computation clearly distinguishes AOP from reﬂection, it also comes at a price: because aspects observe base level computation, evaluating pointcuts and advice at the base level can trigger inﬁnite regression. To avoid these pitfalls, aspect languages propose ad-hoc mechanisms, which increase the complexity for programmers while being insuﬃcient in many cases. After shedding light on the many facets of the issue, this paper proposes to clarify the situation by introducing levels of execution in the programming language, thereby allowing aspects to observe and run at speciﬁc, possibly different, levels. We adopt a defensive default that avoids inﬁnite regression, and gives advanced programmers the means to override this default using level-shifting operators. We then study execution levels both in practice and in theory. First, we study the relevance of the issues addressed by execution levels in existing aspect-oriented programs. We then formalize the semantics of execution levels and prove that the default semantics is indeed free of a certain form of inﬁnite regression, which we call aspect loops. Finally, we report on existing implementations of execution levels for aspect-oriented extensions of Scheme, JavaScript and Java, discussing their implementation techniques and current applications.},
	language = {en},
	urldate = {2021-05-04},
	journal = {Science of Computer Programming},
	author = {Tanter, Éric and Figueroa, Ismael and Tabareau, Nicolas},
	month = feb,
	year = {2014},
	pages = {311--342},
	file = {Tanter et al. - 2014 - Execution levels for aspect-oriented programming .pdf:/Users/michaltakac/Zotero/storage/RRHTLKPR/Tanter et al. - 2014 - Execution levels for aspect-oriented programming .pdf:application/pdf}
}

@inproceedings{ohshimaKedamaGUIBasedInteractive2005,
	address = {Dallas, TX, USA},
	title = {Kedama: {A} {GUI}-{Based} {Interactive} {Massively} {Parallel} {Particle} {Programming} {System}},
	isbn = {978-0-7695-2443-6},
	shorttitle = {Kedama},
	url = {http://ieeexplore.ieee.org/document/1509492/},
	doi = {10.1109/VLHCC.2005.49},
	abstract = {Decentralized and complex systems can be powerful tools for modeling concepts in mathematics, science and engineering. StarLogo and NetLogo were the ﬁrst systems to allow middle and high school children to build dynamic models from many thousands of programmable particles.},
	language = {en},
	urldate = {2021-05-04},
	booktitle = {2005 {IEEE} {Symposium} on {Visual} {Languages} and {Human}-{Centric} {Computing} ({VL}/{HCC}'05)},
	publisher = {IEEE},
	author = {Ohshima, Y.},
	year = {2005},
	pages = {91--98},
	file = {Ohshima - 2005 - Kedama A GUI-Based Interactive Massively Parallel.pdf:/Users/michaltakac/Zotero/storage/3V2PLRK9/Ohshima - 2005 - Kedama A GUI-Based Interactive Massively Parallel.pdf:application/pdf}
}

@incollection{hestenesModelingSoftwareLearning1995,
	address = {Boston, MA},
	title = {Modeling {Software} for {Learning} and {Doing} {Physics}},
	isbn = {978-1-4613-5786-5 978-1-4615-1921-8},
	url = {http://link.springer.com/10.1007/978-1-4615-1921-8_4},
	abstract = {This is the initial report of a long term research program on the design of integrated computer software systems for physics education specifically, and math-science education generally. The program is grounded in a theory of instruction which is centrally concerned with the construction, validation and use of scientific models for objects and processes in the real world. It aims to develop a detailed theory of software design which supports and coordinates all aspects of conceptual and computational modeling. The theory is applied to the design of a versatile Modeling Workstation for learning and doing physics by computer, including the coordination of both experimental and theoretical activities.},
	language = {en},
	urldate = {2021-05-04},
	booktitle = {Thinking {Physics} for {Teaching}},
	publisher = {Springer US},
	author = {Hestenes, David},
	editor = {Bernardini, Carlo and Tarsitani, Carlo and Vicentini, Matilde},
	year = {1995},
	doi = {10.1007/978-1-4615-1921-8_4},
	pages = {25--65},
	file = {Hestenes - 1995 - Modeling Software for Learning and Doing Physics.pdf:/Users/michaltakac/Zotero/storage/NVP6UAVK/Hestenes - 1995 - Modeling Software for Learning and Doing Physics.pdf:application/pdf}
}

@article{chibaniPracticalBenefitsAspectOriented2014a,
	title = {Practical {Benefits} of {Aspect}-{Oriented} {Programming} {Paradigm} in {Discrete} {Event} {Simulation}},
	volume = {2014},
	issn = {1687-5591, 1687-5605},
	url = {http://www.hindawi.com/journals/mse/2014/736359/},
	doi = {10.1155/2014/736359},
	abstract = {Aspect-oriented modeling and simulation is a new approach which uses the separation of concerns principle to enhance the quality of models and simulation tools. It adopts the separation of concerns (SOC) principle. Thus, crosscutting concerns such as processes synchronization, steady state detection, and graphical animation could be separated from simulation functional modules. The capture of crosscutting concerns in a modular way is carried out to cope with complexity and to achieve the required engineering quality factors such as robustness, modularity, adaptability, and reusability. This paper provides a summary of aspect-oriented paradigm with its usage in simulation by illustrating the main crosscutting concerns that may infect simulation systems. A practical example is given with the use of the Japrosim discrete event simulation library.},
	language = {en},
	urldate = {2021-05-04},
	journal = {Modelling and Simulation in Engineering},
	author = {Chibani, Meriem and Belattar, Brahim and Bourouis, Abdelhabib},
	year = {2014},
	pages = {1--16},
	file = {Chibani et al. - 2014 - Practical Benefits of Aspect-Oriented Programming .pdf:/Users/michaltakac/Zotero/storage/LGYN95HR/Chibani et al. - 2014 - Practical Benefits of Aspect-Oriented Programming .pdf:application/pdf}
}

@article{barrosAspectorientedProgrammingPluggable2015a,
	title = {Aspect-oriented programming and pluggable software units: a comparison based on design patterns: {ASPECT}-{ORIENTED} {PROGRAMMING} {AND} {PLUGGABLE} {SOFTWARE} {UNITS}},
	volume = {45},
	issn = {00380644},
	shorttitle = {Aspect-oriented programming and pluggable software units},
	url = {http://doi.wiley.com/10.1002/spe.2224},
	doi = {10.1002/spe.2224},
	abstract = {The support for software reuse has been a major goal in the design of programming languages. This goal, however, has proven difﬁcult to reach, being only partially enabled by current software tools. In particular, reuse is not fully supported by object-oriented programming (OOP). Aspect-oriented programming (AOP) has introduced new operators that extend OOP, enabling a superior support for reusability. However, AOP operators exhibit limitations in supporting software reuse and more powerful constructs are still required. We consider the ability to deﬁne software in an independent manner as the key construct to enable systematic software reuse. To bridge the gap between independence and practical software tools, we have developed the concept of Independent and Pluggable Software Unit (PU), a construct that supports the deﬁnition of software topologies. In this paper, we compare PUs with AOP in their support for reusable software. To enable comparison, we employ some well described problems addressed by Software Design Patterns (SDPs). We provide PU and AOP versions of several SDPs, including, Observer, Composite, Command, Chain of Responsibility, and Proxy. In particular, we show that, whereas PUs provide a uniﬁed representation of design patterns, AOP representations do not achieve this uniﬁcation. We also show that AOP solutions do not promote independent and reusable software. Copyright © 2013 John Wiley \& Sons, Ltd.},
	language = {en},
	number = {3},
	urldate = {2021-05-04},
	journal = {Software: Practice and Experience},
	author = {Barros, Fernando J.},
	month = mar,
	year = {2015},
	pages = {289--314},
	file = {Barros - 2015 - Aspect-oriented programming and pluggable software.pdf:/Users/michaltakac/Zotero/storage/JFRTS5I6/Barros - 2015 - Aspect-oriented programming and pluggable software.pdf:application/pdf}
}

@article{kestenbaumChallengesIDCWhat2005,
	title = {The challenges of {IDC}: what have we learned from our past?},
	volume = {48},
	issn = {0001-0782, 1557-7317},
	shorttitle = {The challenges of {IDC}},
	url = {https://dl.acm.org/doi/10.1145/1039539.1039566},
	doi = {10.1145/1039539.1039566},
	abstract = {A conversation with Seymour Papert, Marvin Minsky, and Alan Kay.},
	language = {en},
	number = {1},
	urldate = {2021-05-04},
	journal = {Communications of the ACM},
	author = {Kestenbaum, David},
	month = jan,
	year = {2005},
	pages = {35--38},
	file = {Kestenbaum - 2005 - The challenges of IDC what have we learned from o.pdf:/Users/michaltakac/Zotero/storage/DRW753SB/Kestenbaum - 2005 - The challenges of IDC what have we learned from o.pdf:application/pdf}
}

@article{joqueInventionObjectObject2016a,
	title = {The {Invention} of the {Object}: {Object} {Orientation} and the {Philosophical} {Development} of {Programming} {Languages}},
	volume = {29},
	issn = {2210-5433, 2210-5441},
	shorttitle = {The {Invention} of the {Object}},
	url = {http://link.springer.com/10.1007/s13347-016-0223-5},
	doi = {10.1007/s13347-016-0223-5},
	abstract = {Programming languages have developed significantly over the past century to provide complex models to think about and describe the world and processes of computation. Out of Alan Kay’s Smalltalk and a number of earlier languages, objectoriented programming has emerged as a preeminent mode of writing and organizing programs. Tracing the history of object-oriented programming from its origins in Simula and Sketchpad through Smalltalk, particularly its philosophical and technical developments, offers unique insights into philosophical questions about objects, language, and our digital technologies. These early attempts to understand objects as basic elements of computation demonstrate the ways in which language, while firmly planted in the material reality of computation, must delimit objects from each other. This essay critically explores this history and explicates a theory of objects suggested by the development of object-oriented programming languages, which insists on the importance of language for representing and delimiting objects. It argues that the philosophies behind object-oriented programming are ultimately opposed to the claims of object-oriented ontology and find themselves more closely allied with philosophies that insist on the mediation of what exists through language.},
	language = {en},
	number = {4},
	urldate = {2021-05-04},
	journal = {Philosophy \& Technology},
	author = {Joque, Justin},
	month = dec,
	year = {2016},
	pages = {335--356},
	file = {Joque - 2016 - The Invention of the Object Object Orientation an.pdf:/Users/michaltakac/Zotero/storage/CPIJD3Y7/Joque - 2016 - The Invention of the Object Object Orientation an.pdf:application/pdf}
}

@inproceedings{mcdirmidUsableLiveProgramming2013,
	address = {Indianapolis, Indiana, USA},
	title = {Usable live programming},
	isbn = {978-1-4503-2472-4},
	url = {http://dl.acm.org/citation.cfm?doid=2509578.2509585},
	doi = {10.1145/2509578.2509585},
	abstract = {Programming today involves code editing mixed with bouts of debugging to get feedback on code execution. For programming to be more ﬂuid, editing and debugging should occur concurrently as live programming. This paper describes how live execution feedback can be woven into the editor by making places in program execution, not just code, navigable so that evaluation results can be probed directly within the code editor. A pane aside the editor also traces execution with entries that are similarly navigable, enabling quick problem diagnosis. Both probes and traces are refreshed continuously during editing, and are easily conﬁgured based on debugging needs. We demonstrate the usefulness of this live programming experience with a prototype.},
	language = {en},
	urldate = {2021-05-04},
	booktitle = {Proceedings of the 2013 {ACM} international symposium on {New} ideas, new paradigms, and reflections on programming \& software - {Onward}! '13},
	publisher = {ACM Press},
	author = {McDirmid, Sean},
	year = {2013},
	pages = {53--62},
	file = {McDirmid - 2013 - Usable live programming.pdf:/Users/michaltakac/Zotero/storage/TR2PEAC8/McDirmid - 2013 - Usable live programming.pdf:application/pdf}
}
